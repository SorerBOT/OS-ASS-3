#include <csignal>
#include <cstddef>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#define SESSION_OUTRO "Focus Mode complete. All distractions are now unblocked.\n"
#define FIRST_ROUND_INTRO "Entering Focus Mode. All distractions are blocked."
#define NON_FIRST_ROUND_INTRO \
    "──────────────────────────────────────────────\n" \
    "             Back to Focus Mode.\n" \
    "══════════════════════════════════════════════\n"

#define ADDITIONAL_ROUND_INTRO \
    "Entering Focus Mode. All distractions are blocked.\n" \
    "══════════════════════════════════════════════\n" \
    "                Focus Round %d                \n" \
    "──────────────────────────────────────────────\n"

#define DISTRACTIONS_INTRO \
    "──────────────────────────────────────────────\n" \
    "        Checking pending distractions...\n" \
    "──────────────────────────────────────────────\n"

#define GET_MESSAGE_PROMPT \
    "Simulate a distraction:\n" \
    "1 = Email notification\n" \
    "2 = Reminder to pick up delivery\n" \
    "3 = Doorbell Ringing\n" \
    "q = Quit\n" \

#define SIGNAL_EMAIL                            SIGUSR1
#define SIGNAL_DELIVERY                         SIGUSR2
#define SIGNAL_DOORBELL                         SIGCHLD

#define MESSAGE_QUIT                            'q'
#define MESSAGE_EMAIL                           '1'
#define MESSAGE_EMAIL_TEXT                      " - Email notification is waiting.\n"
#define MESSAGE_EMAIL_OUTCOME                   "[Outcome:] The TA announced: Everyone get 100 on the exercise!\n"
#define MESSAGE_DELIVERY                        '2'
#define MESSAGE_DELIVERY_TEXT                   " - You have a reminder to pick up your delivery.\n"
#define MESSAGE_DELIVERY_OUTCOME                "[Outcome:] You picked it up just in time.\n"
#define MESSAGE_DOORBELL                        '3'
#define MESSAGE_DOORBELL_TEXT                   " - The doorbell is ringing.\n"
#define MESSAGE_DOORBELL_OUTCOME                "[Outcome:] Food delivery is here.\n"

typedef enum
{
    false,
    true
} boolean;

char GetMessage();
void PlayRound(int roundNumber, int duration);
void ProcessSignals(const int* singals, int signalsCount);
void HandleFocusMode(int roundNumber, int duration);
void SendSignal(char message);
int FindNewSignal(int* seenSignals, int seenSignalsCount);

void HandleFocusMode(int numOfRounds, int duration)
{
    for (int i = 0; i < numOfRounds; i++)
        PlayRound(i, duration);

    // for some reason it was printed this way in the example
    printf(NON_FIRST_ROUND_INTRO);
    printf(SESSION_OUTRO);
}

char GetMessage()
{
    char messageType = -1;

    printf(GET_MESSAGE_PROMPT);
    scanf(" %c", &messageType);

    return messageType;
}

void PlayRound(int roundNumber, int duration)
{
    int* seenSignals = (int*)malloc(duration * sizeof(int));
    int seenSignalsCount = 0;

    printf(roundNumber == 0 ? FIRST_ROUND_INTRO : NON_FIRST_ROUND_INTRO);
    printf(ADDITIONAL_ROUND_INTRO, 1);

    for (int i = 0; i < duration; i++)
    {
        int newSignal = -1;

        int message = GetMessage();
        if (message == MESSAGE_QUIT)
            break;

        SendSignal(message);
        newSignal = FindNewSignal(seenSignals, seenSignalsCount);
        if (newSignal == -1)
            continue;


        seenSignals[seenSignalsCount] = newSignal;
        seenSignalsCount++;
    }

    printf(DISTRACTIONS_INTRO);
    ProcessSignals(seenSignals, seenSignalsCount);
    free(seenSignals);
}

void ProcessSignals(const int* signals, int signalsCount)
{
    for (int i = 0; i < signalsCount; i++)
    {
        char* messageText = NULL;
        char* messageOutcome = NULL;

        switch (signals[i])
        {
            case SIGNAL_EMAIL:
                messageText = MESSAGE_EMAIL_TEXT;
                messageOutcome = MESSAGE_EMAIL_OUTCOME;
                break;
            case SIGNAL_DELIVERY:
                messageText = MESSAGE_DELIVERY_TEXT;
                messageOutcome = MESSAGE_DELIVERY_OUTCOME;
                break;
            case SIGNAL_DOORBELL:
                messageText = MESSAGE_DOORBELL_TEXT;
                messageOutcome = MESSAGE_DOORBELL_OUTCOME;
                break;
            default:
                perror("Invalid argument error: '%d' is an invalid signal number", signals[i])
                break;
        }

        printf("%s", messageText);
        printf("%s", messageOutcome);
    }
}

void SendSignal(char message)
{
    int signalNumber = -1;
    switch (message)
    {
        case MESSAGE_EMAIL:
            signalNumber = SIGUSR1;
            break;
        case MESSAGE_DELIVERY:
            signalNumber = SIGUSR2;
            break;
        case MESSAGE_DOORBELL:
            signalNumber = SIGCHLD;
            break;
        default:
            break;
    }

    if (signalNumber == -1)
    {
        printf("Invalid argument error: '%c' is invalid", message);
        exit(EXIT_FAILURE);
    }

    raise(signalNumber);
}

void Consumer()
{
    sigset_t signalsToUnblockMask;
    sigemptyset(&signalsToUnblockMask);

    sigaddset(&signalsToUnblockMask, SIGUSR1);
    sigaddset(&signalsToUnblockMask, SIGUSR2);
    sigaddset(&signalsToUnblockMask, SIGCHLD);

    if (sigprocmask(SIG_UNBLOCK, &signalsToUnblockMask, NULL) == -1)
    {
        perror("unblocking signals failed");
        exit(EXIT_FAILURE);
    }
}

int FindNewSignal(int* seenSignals, int seenSignalsCount)
{
}
